---
eip: 75XXc
title: Prover and Sequnecer Bridge API
description: Bridge part of interface between Provers and Sequencer Blockchain Clients
author: Peter Robinson (@drinkcoffee)
discussions-to: TODO Eth Magicians URL
status: Draft
type: Standards Track
category: Core
created: 2023-10-27
---


## Abstract

This EIP defines the bridging parts of the interface that allows stateless zero knowledge provers to collect state information from blockchain nodes that are operating as sequencers. This EIP is designed to be used in conjunction with [EIP-75XXa](./eip-75XXa.md), which defines the main interface between provers and sequencers, and [EIP-75XXb](./eip-75XXb.md), which defines a minimal set of properties for proving consensus.


## Motivation

Decentralized sequencers for zero knowledge rollups can be implemented as a blockchain. Centralized sequencer can be implemented as a single node blockchain. This blockchain holds state, and via a consensus protocol, allows nodes to come to agreement on the order of blocks. Provers can operate statelessly, fetch finalised blocks of transactions and state from the blockchain nodes. The proofs generated by the provers can then be verified on Ethereum. This type of rollup system is shown in the figure below.

![Decentralized Sequencer Architecture](../assets/eip-75XX/architecture.png)

This specification defines values to facilitate an L2 to L1 bridge. The bridge design is not dictated by this specification. Instead this specification specifies a minimal set of storage slots that need to be proven for each block to allow for the operation of the bridge. 

This specification defines:

* System configuration parameters.
* Storage slots whose values need to be proven at the end of each block.
* Required features of an arbitrary message bridge smart contract.




## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Initialisation

The table below described the configuration values that must be supplied to the blockchain client(s) and the prover at system start-up. 

<table>
<thead>
<tr>
  <th>Name</th>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>L2L1BridgeContractAddress</td>
  <td>ADDRESS</td>
  <td>Address of L2 to L1 arbitrary message bridge contract.</td>
</tr>
<tr>
  <td>L2L1WithdrawTreeRootStorageSlot</td>
  <td>UINT256</td>
  <td>Storage slot of WithdrawTreeRoot value within the L2 to L1 arbitrary message bridge contract.</td>
</tr>
</tbody>
</table>


### Final Block Storage to be Proven

The storage slots defined in the initialisation above need to be proven as part of the Final Block Storage of the BlockInformationType defined in EIP-75XXa (see [EIP-75XXa](./eip-75XXa.md#blockinformationtype)). That is, the WithdrawalTreeRoot for the L2 to L1 arbitrary message bridge contract needs to be proven.


### L2 to L1 Bridge Contract

This section defines the requirements related to the L2 to L1 bridge contract.

All rollups MUST have an L2 to L1 arbitrary message bridge contract. The contract MUST contain a storage value ```l2L1WithdrawalTreeRoot```, that summarises the messages that have been communicated between L2 and L1.

```solidity
bytes32 l2L1WithdrawalTreeRoot;
```

## Rationale

This section explains the rationale behind design decisions contained in this specification.

### Having Bridge information in Final Block Storage to be Proven

The reason for proving the value of ```l2L1WithdrawalTreeRoot``` from the L2 to L1 arbitrary message bridge contract is so that the value can be published as part of the proof, and then submitted to the verifier contract on L1. The verifier contract could then have this value readily available, rather than needing a Merkle Proof to be submitted, so that crosschain bridges can then efficiently use the value as part of their bridging system.

The reason for proving the value of ```l2L1WithdrawalTreeRoot``` at the end of the block is so that crosschain bridge systems can use this value to validate crosschain transfers that have occurred during the block. Depending on the design of the bridging system, the single value may allow all historic crosschain transactions to be validated.

The reason for proving the value of ```l2L1WithdrawalTreeRoot``` even if it hasn't changed is to simplify the logic of the proving system and verification contract.


### L2 to L1 Bridge Contract

The ```l2L1WithdrawalTreeRoot``` is the only storage value defined for the L2 to L1 bridge. This could be the root of a Sparse Merkle Tree of all crosschain messages that have been processed on L2. When this value is available via the proof on L1, users will be able to submit exit transactions based on this Merkle Tree Root value. 


## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

None.

## Reference Implementation

None.


## Security Considerations

The following security implications should be considered:

* TODO

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
