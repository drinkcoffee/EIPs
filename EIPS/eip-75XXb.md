---
eip: 75XXb
title: Prover and Sequencer Consensus API
description: Consensus part of interface between Provers and Decentralized Sequencer Blockchain Clients
author: Peter Robinson (@drinkcoffee)
discussions-to: TODO Eth Magicians URL
status: Draft
type: Standards Track
category: Core
created: 2023-10-27
---


## Abstract

This EIP defines the consensus parts of the interface that allows stateless zero knowledge provers to collect state information from blockchain nodes that are operating as decentralized sequencers.This EIP is designed to be used in conjunction with ![EIP-75XXa](../EIP-75XXa.md), which defines the main interface between provers and sequencers, and ![EIP-75XXc](../EIP-75XXc.md), which defines a minimal set of properties for bridging.

## Motivation

Decentralized sequencers for zero knowledge rollups can be implemented as a blockchain. This blockchain holds state, and via a consensus protocol, allows nodes to come to agreement on the order of blocks. Provers can operate statelessly, fetch finalised blocks of transactions and state from the blockchain nodes. The proofs generated by the provers can then be verified on Ethereum. This type of rollup system is shown in the figure below.

![Decentralized Sequencer Architecture](../assets/eip-75XX/architecture.png)

This specification defines values to facilitate _proof of consensus_. That is, proving that the validators of the decentralized sequencer blockchain came to consensus on the block that is being proven.

This specification defines:

* System configuration parameters.
* Storage slots whose values need to be proven at the end of each block.
* Required features of a validator set smart contract.




## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Initialisation

TODO Things to be defined:

* Address of Validator Set contract
* Storage slot of validator set map in Validator Set contract.
* Storage slot of the total number of validators in the Validator Set contract.
* Threshold algorithm for consensus protocol.
* Validator signing configuration: 
  * ECDSA secp256k1 with KECCAK256
  * Aggregated BLS 12-381 with KECCAK256



### Final Block Storage to be Proven

The following storage slots need to be proven as part of the Final Block Storage section of the BlockInformationType defined in EIP-75XXa:

* Each validator that signed the block header.
* Total number of validators.


### Validator Contract

The information stored in the validator contract depends on the validator signing configuration.

#### ECDSA secp256k1 with KECCAK256

Validators are stored in a mapping and the total number of validators is stored as a uint256 as shown below.

```solidity
mapping (address => uint256) validatorStakes;
uint256 numValidators;
```

Validators are deemed to be active if the uint256 value for a validatorStakes's address is non-zero.

The storage slot specified in the initialisation is where the ```validatorStakes``` variable appears in the storage map. The storage slot for a validator's entry in the mapping can be calculated by calculating the equation shown below.

```
Validator Storage Slot = Keccak256(Storage Slot of Mapping, Address of Validator)
```


#### BLS 12-381 with KECCAK256

Validators are stored in a mapping and the total number of validators is stored as a uint256 as shown below.

```solidity
struct ValidatorInfo {
  uint256 validatorStake
  bytes publicKey;
}

mapping (bytes32 => uint256) validators;
uint256 numValidators;
```

Validators are identified by an identifier. This identifier could be the keccak256 of the validator's public key.

Validators are deemed to be active if the validatorStake value for a validator is non-zero.

The storage slot specified in the initialisation is where the ```validators``` variable appears in the storage map. The storage slot for a validator's stake in the mapping can be calculated by calculating the equation shown below.

```
Validator Stake Slot = Keccak256(Storage Slot of Mapping, Validator Identifier)
```

The storage slot for a validator's public key in the mapping can be calculated by calculating the equation shown below.

```
Validator Public Key Slot = Keccak256(Storage Slot of Mapping, Validator Identifier) + 1
```


## Rationale

This section explains the rationale behind design decisions contained in this specification.


### Validator Contract

Having a validator contract that defines which entities can approve blocks is useful for the following reasons:

* Proving of validator changes is done as part of transaction proving. That is, when validators are controlled by a contract, transactions are used to add or remove validators. Provers then prove the transactions related to validator changes in the same way as they prove any other transaction. 
* Arbitrary logic can be applied used for adding or removing validators. That is, the validator contract can support any logic for controlling validators. From a proving system perspective, the only thing that needs to be defined is the list of approved validators.



## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

None.

## Reference Implementation

None.


## Security Considerations

The following security implications should be considered:

* The consensus protocol used by the decentralised sequencer blockchain nodes should be Byzantine Fault Tolerant. That is, it should be able to handle some faulty or malicious nodes. In this way, the prover will receive the correct state, not matter which node it communicates with, even if some of the nodes in the decentralised sequencer blockchain are malicious.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
