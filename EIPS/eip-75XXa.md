---
eip: 75XXa
title: Prover and Decentralized Sequencer API
description: Interface between Provers and Decentralized Sequencer Blockchain Clients
author: Peter Robinson (@drinkcoffee)
discussions-to: TODO Eth Magicians URL
status: Draft
type: Standards Track
category: Core
created: 2023-10-27
---


## Abstract

This EIP defines the interface that allows stateless zero knowledge provers to collect state information from blockchain nodes that are operating as decentralized sequencers. This EIP is designed to be used in conjunction with [EIP-75XXb](./eip-75XXb.md), which defines a minimal set of properties for proving consensus, and [EIP-75XXc](./eip-75XXc.md), which defines a minimal set of properties for bridging.


## Motivation

Decentralized sequencers for zero knowledge rollups can be implemented as a blockchain. This blockchain holds state, and via a consensus protocol, allows nodes to come to agreement on the order of blocks. Provers can operate statelessly, fetch finalised blocks of transactions and state from the blockchain nodes. The proofs generated by the provers can then be verified on Ethereum. This type of rollup system is shown in the figure below.

![Decentralized Sequencer Architecture](../assets/eip-75XX/architecture.png)

This specification defines:

* System configuration parameters.
* APIs including data formats for returning all the information needed for a stateless prover to prove a block:
  * The block header.
  * End of block state for selected values to facilitate proof of consensus and bridging.
  * Per transaction state prior to transaction execution.
  * Per transaction transaction receipts that can be used as check values.


## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Initialisation

TODO Things to be defined:

* Chain Id
* Storage proof format. 
  * Merkle Patricia Trie.
* Hash function to use:
  * Keccak 256
  * Possiden


### JSON RPC APIs

#### getBlockTraceByNumber

*Parameters*: 

* Block number: String with format: ```^0x([1-9a-f]+[0-9a-f]*|0)$```

*Returns*:

* Block information: <a href="#BlockInformationType">BlockInformationType</a>.


#### getBlockTraceByHash

*Parameters*: 

* Block hash: String with format: ```^0x[0-9a-f]{64}$```

*Returns*:

* Block information: <a href="#BlockInformationType">BlockInformationType</a>.


### Data Types

#### BlockInformationType

The following table describes the information contained in the ```BlockInformationType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Chain Id</td>
  <td>chainID</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Chain id of rollup.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Header</td>
  <td>header</td>
  <td><a href="#BlockHeaderType">BlockHeaderType</a></td>
  <td></td>
  <td>Block header of block being proven.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transactions</td>
  <td>transactions</td>
  <td>Array of <a href="#TransactionType">TransactionType</a></td>
  <td></td>
  <td>Transactions that executed in the block being proven.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Final Block Storage</td>
  <td>blockStorage</td>
  <td>Array of <a href="#StorageType">StorageType</a></td>
  <td></td>
  <td>Array of storage information after the last transaction in the block. This storage information includes the storage slots to faciliate <i>proof of consensus</i> (see <a href="./eip-75XXb.md">EIP-75XXb</a>) and bridging (see <a href="./eip-75XXc.md">EIP-75XXc</a>).</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transaction Storage</td>
  <td>transactionStorage</td>
  <td>Array of <a href="#StorageTraceType">StorageTraceType</a></td>
  <td></td>
  <td>Storage information at the start of each transaction. The storage information is for any storage slot within any account that is read from or written to during the execution of the transaction.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transaction Receipts</td>
  <td>transactionReceipts</td>
  <td>Array of <a href="#ReceiptType">ReceiptType</a></td>
  <td></td>
  <td>One transaction receipt for each transaction in the block.</td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### BlockHeaderType

The following table describes the information contained in the ```BlockHeaderType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>ParentHash</td>
  <td>parentHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Block hash of parent block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>UncleHash</td>
  <td>sha3Uncles</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Hash or Ommers. <code>0x00</code> if the consensus protocol does not support Ommers.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Coinbase</td>
  <td>miner</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>Address of entity that mined this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>State Root</td>
  <td>stateRoot</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Root of storage tree.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transaction Root</td>
  <td>transactionsRoot</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Root of transaction tree for transactions contained in this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transaction Receipts Root</td>
  <td>receiptsRoot</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Root of transaction receipts tree for transactions contained in this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Bloom</td>
  <td>logsBloom</td>
  <td>String</td>
  <td>^0x[0-9a-f]{512}$</td>
  <td>Bloom filter for logs emitted by transactions in this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Difficulty</td>
  <td>difficulty</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Block difficults, previous value of RANDAO, or <code>0x00</code> depending on the decentralized sequencer.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>number</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Block number. Block 0 is the virtual block created from the genesis file.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Gas Limit</td>
  <td>getLimit</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The maximum amount of gas that could be used in this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Gas Used</td>
  <td>getUsed</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The amount of gas used by the transactions in this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block time stamp</td>
  <td>timestamp</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The time a sequencer produced this block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Extra Data</td>
  <td>extraData</td>
  <td>String</td>
  <td>^0x[0-9a-f]*$</td>
  <td>Information about the consensus algorithm and signers. See <a href="./eip-75XXb.md">EIP-75XXb</a> for values for this field.
  <td>Yes</td>
  </td>
</tr>
<tr>
  <td>Mix Digest</td>
  <td>mixHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Nonce</td>
  <td>nonce</td>
  <td>String</td>
  <td>^0x[0-9a-f]{16}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Base Fee</td>
  <td>baseFeePerGas</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>EIP 1559 base fee. TODO: Should EIP 1559 be optional?</td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### TransactionType

The following table describes the information contained in the ```TransactionType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Type</td>
  <td>type</td>
  <td>String</td>
  <td>^0x([0-9,a-f,A-F]?){1,2}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Nonce</td>
  <td>nonce</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Gas Limit</td>
  <td>gas</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Gas Price</td>
  <td>gasPrice</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>From</td>
  <td>from</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>EOA that submitted this transaction.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>To</td>
  <td>to</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>EOA of contract address that transaction targetted at.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Value</td>
  <td>value</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Amount in Wei sent to the <code>To</code> account.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Data</td>
  <td>input</td>
  <td>String</td>
  <td>^0x[0-9a-f]*$</td>
  <td>Transaction data. For ABI encoding compliant contracts, this is a function selector followed by parameters.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>V</td>
  <td>v</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>R</td>
  <td>r</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>S</td>
  <td>s</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>IsCreate</td>
  <td>isCreate</td>
  <td>Boolean</td>
  <td></td>
  <td></td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### StorageType

Storage Type contains a proof for a specific storage slot in a specific account. The following table describes the information contained in the ```StorageType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account Proofs</td>
  <td>proofs</td>
  <td>Array of <a href="#AccountProofType">AccountProofType</a></td>
  <td></td>
  <td>Proof for account information.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Storage Proofs</td>
  <td>storageProofs</td>
  <td>Array of <a href="#StorageProofType">StorageProofType</a></td>
  <td></td>
  <td>Proofs for storage slots within accounts.</td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### StorageTraceType

```StorageTraceType``` defines all of the storage information needed to execute a transaction. The following table describes the information contained in the ```StorageTraceType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>StorageRootBefore</td>
  <td>storageRootBefore</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Storage root prior to executing the transaction.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Account Proofs</td>
  <td>proofs</td>
  <td>Array of <a href="#AccountProofType">AccountProofType</a></td>
  <td></td>
  <td>Proof for account information.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Storage Proofs</td>
  <td>storageProofs</td>
  <td>Array of <a href="#StorageProofType">StorageProofType</a></td>
  <td></td>
  <td>Proofs for storage slots within accounts.</td>
  <td>Yes</td>
</tr>
</tbody>
</table>



#### AccountProofType

Account Proof Type contains a proof for a specific account. The following table describes the information contained in the ```AccountProofType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account</td>
  <td>account</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>Address of an account.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Nonce</td>
  <td>nonce</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Account nonce.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Balance</td>
  <td>balance</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Account balance.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Code</td>
  <td>code</td>
  <td>String</td>
  <td>^0x[0-9a-f]*$</td>
  <td>Account's contract code.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Proof</td>
  <td>proof</td>
  <td>Array of String</td>
  <td>Array of ^0x[0-9a-f]{64}$</td>
  <td>Merkle proof for an account. An array of hashes.</td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### StorageProofType

Storage Proof Type contains a proof for a specific storage slot in a specific account. The following table describes the information contained in the ```StorageProofType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account</td>
  <td>account</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>Address of an account.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Slot</td>
  <td>slot</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Storage slot number.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Value</td>
  <td>value</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Value at the storage slot.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Proof</td>
  <td>proof</td>
  <td>Array of String</td>
  <td>Array of ^0x[0-9a-f]{64}$</td>
  <td>Merkle proof for a storage slot. The array is an array of hashes.</td>
  <td>Yes</td>
</tr>
</tbody>
</table>


#### ReceiptType

One ```ReceiptsType``` structure is returned for each transaction. The information in this structure is not needed to prove the execution trace of all the transactions in a block as the block header contains the final state root. However, it will assist the proving of a transaction, providing per-transaction information that can be checked. 

The following table describes the information contained in the ```ReceiptType```. The information mirrors the value returned by <code>eth_getTransactionReceipt</code> with the following exceptions:

* The ```Post Transaction State Root``` should always be returned.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Type</td>
  <td>type</td>
  <td>String</td>
  <td>^0x([0-9,a-f,A-F]?){1,2}$</td>
  <td>Transaction type.</td>
  <td>No</td>
</tr>
<tr>
  <td>Transaction Hash</td>
  <td>txHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Transaction Index</td>
  <td>transactionIndex</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Index of this transaction within the block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Hash</td>
  <td>blockHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>blockNumber</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>From</td>
  <td>from</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>To</td>
  <td>to</td>
  <td>String</td>
  <td>Either null or ^0x[0-9,a-f,A-F]{40}$</td>
  <td><code>Null</code> for contract creation. Recipient address otherwise.</td>
  <td>No</td>
</tr>
<tr>
  <td>Cumulative Gas Used</td>
  <td>cumulativeGasUsed</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Amount of gas used by this transaction and all previous transactions in the block.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Gas Used</td>
  <td>gasUsed</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Amount of gas used by this transaction.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Blob Gas Used</td>
  <td>blobGasUsed</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The amount of blob gas used for this specific transaction. Only specified for blob transactions as defined by EIP-4844.</td>
  <td>No</td>
</tr>
<tr>
  <td>Contract Address</td>
  <td>contractAddress</td>
  <td>String</td>
  <td>Null or ^0x[0-9,a-f,A-F]{40}$</td>
  <td>Address of deployed contract if the transaction was a create contract, <code>null</code> otherwise.</td>
  <td>No</td>
</tr>
<tr>
  <td>Logs</td>
  <td>logs</td>
  <td>Array of <a href="#LogType">LogType</a></td>
  <td></td>
  <td>Array of events emmitted during the transaction execution.</td>
  <td></td>
</tr>
<tr>
  <td>Logs Bloom</td>
  <td>logBloom</td>
  <td>String</td>
  <td>^0x[0-9a-f]{512}$</td>
  <td>Bloom filter for log.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Post Transaction State Root</td>
  <td>root</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td>Storage root after to executing the transaction. <b>NOTE:</b> Unlike transaction receipts returned by <code>eth_getTransactionReceipt</code>, this field is required for all transactions.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Status</td>
  <td>status</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td><code>1</code> if the transaction is successful and ```0``` if the transaction failed.</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Effective Gas Price</td>
  <td>effectiveGasPrice</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The actual value per gas deducted from the sender's account. Before EIP-1559, this is equal to the transaction's gas price. After, it is equal to baseFeePerGas + min(maxFeePerGas - baseFeePerGas, maxPriorityFeePerGas).</td>
  <td>Yes</td>
</tr>
<tr>
  <td>Blob Gas Price</td>
  <td>blobGasPrice</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>The actual value per gas deducted from the sender's account for blob gas. Only specified for blob transactions as defined by EIP-4844.</td>
  <td>No</td>
</tr>
</tbody>
</table>


#### LogType

```LogType``` contains information emitted for one event during the execution of a transaction. The following table describes the information contained in the ```LogType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Pattern</th>
  <th>Description</th>
  <th>Required</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Removed</td>
  <td>removed</td>
  <td>Boolean</td>
  <td></td>
  <td>The ```Removed``` field is true if this log was reverted due to a chain reorganisation.</td>
  <td>No</td>
</tr>
<tr>
  <td>Log Index</td>
  <td>logIndex</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Index of this log within the transaction.</td>
  <td>No</td>
</tr>
<tr>
  <td>Transaction Index</td>
  <td>transactionIndex</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td>Index of this transaction within the block.</td>
  <td>No</td>
</tr>
<tr>
  <td>Transaction Hash</td>
  <td>transactionHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td></td>
  <td>Yes</td>
</tr>
<tr>
  <td>Block Hash</td>
  <td>blockHash</td>
  <td>String</td>
  <td>^0x[0-9a-f]{64}$</td>
  <td></td>
  <td>No</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>blockNumber</td>
  <td>String</td>
  <td>^0x([1-9a-f]+[0-9a-f]*|0)$</td>
  <td></td>
  <td>No</td>
</tr>
<tr>
  <td>Address</td>
  <td>address</td>
  <td>String</td>
  <td>^0x[0-9,a-f,A-F]{40}$</td>
  <td>Address of contract that emitted the event.</td>
  <td>No</td>
</tr>
<tr>
  <td>Data</td>
  <td>data</td>
  <td>String</td>
  <td>^0x[0-9a-f]*$</td>
  <td>Event parameters that are not topics.</td>
  <td>No</td>
</tr>
<tr>
  <td>Topics</td>
  <td>topics</td>
  <td>Array String</td>
  <td>Array of ^0x[0-9a-f]{64}$</td>
  <td>Array of log topics.</td>
  <td>No</td>
</tr>
</tbody>
</table>




## Rationale

This section explains the rationale behind design decisions contained in this specification.


### Block Information data structure

The following sections explain why each piece of information is required in the Block Information data structure.

#### Chain Id

The ```Chain Id``` is required to ensure the block information is not mistakenly replayed for a different rollup.

#### Block Header

The ```Block Header``` includes information required to prove consensus.






TODO: Explain the rationale for each piece of data being returned.

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

None.

## Reference Implementation

None.


## Security Considerations

The following security implications should be considered:

* Provers should only request blocks from decentralised sequencer blockchain nodes that are final. That is, proofs should only be generated and posted to Ethereum that represent finalised blocks from the decentralised sequencer.
* Provers implicitly trust the decentralised sequencer blockchain. Decentralised sequencer blockchain nodes could collude to generate a fork of the canonical blockchain. They could deliver state to the provers based on the fork. This specification assumes that decentralised sequencer blockchain nodes will not collude.
* The consensus protocol used by the decentralised sequencer blockchain nodes should be Byzantine Fault Tolerant. That is, it should be able to handle some faulty or malicious nodes. In this way, the prover will receive the correct state, not matter which node it communicates with, even if some of the nodes in the decentralised sequencer blockchain are malicious.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
