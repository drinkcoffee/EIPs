---
eip: 75XXa
title: Prover and Decentralized Sequencer API
description: Interface between Provers and Decentralized Sequencer Blockchain Clients
author: Peter Robinson (@drinkcoffee)
discussions-to: TODO Eth Magicians URL
status: Draft
type: Standards Track
category: Core
created: 2023-10-27
---


## Abstract

This EIP defines the interface that allows stateless zero knowledge provers to collect state information from blockchain nodes that are operating as decentralized sequencers. This EIP is designed to be used in conjunction with [EIP-75XXb](./eip-75XXb.md), which defines a minimal set of properties for proving consensus, and [EIP-75XXc](./eip-75XXc.md), which defines a minimal set of properties for bridging.


## Motivation

Decentralized sequencers for zero knowledge rollups can be implemented as a blockchain. This blockchain holds state, and via a consensus protocol, allows nodes to come to agreement on the order of blocks. Provers can operate statelessly, fetch finalised blocks of transactions and state from the blockchain nodes. The proofs generated by the provers can then be verified on Ethereum. This type of rollup system is shown in the figure below.

![Decentralized Sequencer Architecture](../assets/eip-75XX/architecture.png)

This specification defines:

* System configuration parameters.
* APIs including data formats for returning all the information needed for a stateless prover to prove a block:
  * The block header.
  * End of block state for selected values to facilitate proof of consensus and bridging.
  * Per transaction state prior to transaction execution.
  * Per transaction transaction receipts that can be used as check values.


## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Initialisation

TODO Things to be defined:

* Chain Id
* Storage proof format. 
  * Merkle Patricia Trie.
* Hash function to use:
  * Keccak 256
  * Possiden


### JSON RPC APIs

#### getBlockTraceByNumber

*Parameters*: 

* Block number: Hex string.

*Returns*:

* Block information: <a href="#BlockInformationType">BlockInformationType</a>.


#### getBlockTraceByHash

*Parameters*: 

* Block hash: Hex string.

*Returns*:

* Block information: <a href="#BlockInformationType">BlockInformationType</a>.


### Data Types

#### BlockInformationType

The following table describes the information contained in the ```BlockInformationType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Chain Id</td>
  <td>chainID</td>
  <td>Hex string</td>
  <td>Chain id of rollup.</td>
</tr>
<tr>
  <td>Block Header</td>
  <td>header</td>
  <td><a href="#BlockHeaderType">BlockHeaderType</a></td>
  <td>Block header of block being proven.</td>
</tr>
<tr>
  <td>Transactions</td>
  <td>transactions</td>
  <td>Array of <a href="#TransactionType">TransactionType</a></td>
  <td>Transactions that executed in the block being proven.</td>
</tr>
<tr>
  <td>Final Block Storage</td>
  <td>blockStorage</td>
  <td>Array of <a href="#StorageType">StorageType</a></td>
  <td>Array of storage information after the last transaction in the block. This storage information includes the storage slots to faciliate <i>proof of consensus</i> (see <a href="./eip-75XXb.md">EIP-75XXb</a>) and bridging (see <a href="./eip-75XXc.md">EIP-75XXc</a>).</td>
</tr>
<tr>
  <td>Transaction Storage</td>
  <td>transactionStorage</td>
  <td>Array of <a href="#StorageTraceType">StorageTraceType</a></td>
  <td>Storage information at the start of each transaction. The storage information is for any storage slot within any account that is read from or written to during the execution of the transaction.</td>
</tr>
<tr>
  <td>Transaction Receipts</td>
  <td>transactionReceipts</td>
  <td>Array of <a href="#ReceiptType">ReceiptType</a></td>
  <td>One transaction receipt for each transaction in the block.</td>
</tr>
</tbody>
</table>


#### BlockHeaderType

The following table describes the information contained in the ```BlockHeaderType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>ParentHash</td>
  <td>parentHash</td>
  <td>Hex string</td>
  <td>Block hash of parent block.</td>
</tr>
<tr>
  <td>UncleHash</td>
  <td>sha3Uncles</td>
  <td>Hex string</td>
  <td>Hash or Ommers. <code>0x00</code> if the consensus protocol does not support Ommers.</td>
</tr>
<tr>
  <td>Coinbase</td>
  <td>miner</td>
  <td>Hex string</td>
  <td>Address of entity that mined this block.</td>
</tr>
<tr>
  <td>State Root</td>
  <td>stateRoot</td>
  <td>Hex string</td>
  <td>Root of storage tree.</td>
</tr>
<tr>
  <td>Transaction Root</td>
  <td>transactionsRoot</td>
  <td>Hex string</td>
  <td>Root of transaction tree for transactions contained in this block.</td>
</tr>
<tr>
  <td>Transaction Receipts Root</td>
  <td>receiptsRoot</td>
  <td>Hex string</td>
  <td>Root of transaction receipts tree for transactions contained in this block.</td>
</tr>
<tr>
  <td>Bloom</td>
  <td>logsBloom</td>
  <td>Hex string</td>
  <td>Bloom filter for logs emitted by transactions in this block.</td>
</tr>
<tr>
  <td>Difficulty</td>
  <td>difficulty</td>
  <td>Hex string</td>
  <td>Block difficults, previous value of RANDAO, or <code>0x00</code> depending on the decentralized sequencer.</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>number</td>
  <td>Hex string</td>
  <td>Block number. Block 0 is the virtual block created from the genesis file.</td>
</tr>
<tr>
  <td>Gas Limit</td>
  <td>getLimit</td>
  <td>Hex string</td>
  <td>The maximum amount of gas that could be used in this block.</td>
</tr>
<tr>
  <td>Gas Used</td>
  <td>getUsed</td>
  <td>Hex string</td>
  <td>The amount of gas used by the transactions in this block.</td>
</tr>
<tr>
  <td>Block time stamp</td>
  <td>timestamp</td>
  <td>Hex string</td>
  <td>The time a sequencer produced this block.</td>
</tr>
<tr>
  <td>Extra Data</td>
  <td>extraData</td>
  <td>Hex string</td>
  <td>Information about the consensus algorithm and signers. See <a href="./eip-75XXb.md">EIP-75XXb</a> for values for this field.
  </td>
</tr>
<tr>
  <td>Mix Digest</td>
  <td>mixHash</td>
  <td>Hex string</td>
  <td>TODO</td>
</tr>
<tr>
  <td>Block Nonce</td>
  <td>nonce</td>
  <td>Hex string</td>
  <td>TODO</td>
</tr>
<tr>
  <td>Base Fee</td>
  <td>baseFeePerGas</td>
  <td>Hex string</td>
  <td>EIP 1559 base fee. TODO: Should EIP 1559 be optional?</td>
</tr>
</tbody>
</table>


#### TransactionType

The following table describes the information contained in the ```TransactionType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Type</td>
  <td>type</td>
  <td>Number</td>
  <td></td>
</tr>
<tr>
  <td>Nonce</td>
  <td>nonce</td>
  <td>Number</td>
  <td></td>
</tr>
<tr>
  <td>Gas</td>
  <td>gas</td>
  <td>Number</td>
  <td></td>
</tr>
<tr>
  <td>Gas Price</td>
  <td>gasPrice</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>From</td>
  <td>from</td>
  <td>Hex string</td>
  <td>EOA that submitted this transaction.</td>
</tr>
<tr>
  <td>To</td>
  <td>to</td>
  <td>Hex string</td>
  <td>EOA of contract address that transaction targetted at.</td>
</tr>
<tr>
  <td>Value</td>
  <td>value</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Data</td>
  <td>data</td>
  <td>Hex string</td>
  <td>Transaction data. For ABI encoding compliant contracts, this is a function selector followed by parameters.</td>
</tr>
<tr>
  <td>V</td>
  <td>v</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>R</td>
  <td>r</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>S</td>
  <td>s</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>IsCreate</td>
  <td>isCreate</td>
  <td>Boolean</td>
  <td></td>
</tr>
</tbody>
</table>


#### StorageType

Storage Type contains a proof for a specific storage slot in a specific account. The following table describes the information contained in the ```StorageType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account Proofs</td>
  <td>proofs</td>
  <td>Array of <a href="#AccountProofType">AccountProofType</a></td>
  <td>Proof for account information.</td>
</tr>
<tr>
  <td>Storage Proofs</td>
  <td>storageProofs</td>
  <td>Array of <a href="#StorageProofType">StorageProofType</a></td>
  <td>Proofs for storage slots within accounts.</td>
</tr>
</tbody>
</table>


#### StorageTraceType

```StorageTraceType``` defines all of the storage information needed to execute a transaction. The following table describes the information contained in the ```StorageTraceType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>StorageRootBefore</td>
  <td>storageRootBefore</td>
  <td>Hex string</td>
  <td>Storage root prior to executing the transaction.</td>
</tr>
<tr>
  <td>Account Proofs</td>
  <td>proofs</td>
  <td>Array of <a href="#AccountProofType">AccountProofType</a></td>
  <td>Proof for account information.</td>
</tr>
<tr>
  <td>Storage Proofs</td>
  <td>storageProofs</td>
  <td>Array of <a href="#StorageProofType">StorageProofType</a></td>
  <td>Proofs for storage slots within accounts.</td>
</tr>
<tr>
  <td>Deletion Proofs</td>
  <td>deletionProofs</td>
  <td>Array of <a href="#AccountProofType">AccountProofType</a></td>
  <td>Proof for accounts that have ```selfdescructed``` during the execution of the transaction.</td>
</tr>
</tbody>
</table>



#### AccountProofType

Account Proof Type contains a proof for a specific account. The following table describes the information contained in the ```AccountProofType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account</td>
  <td>account</td>
  <td>Hex string</td>
  <td>Address of an account.</td>
</tr>
<tr>
  <td>Nonce</td>
  <td>nonce</td>
  <td>Number</td>
  <td>Account nonce.</td>
</tr>
<tr>
  <td>Balance</td>
  <td>balance</td>
  <td>Hex string</td>
  <td>Account balance.</td>
</tr>
<tr>
  <td>Code</td>
  <td>code</td>
  <td>Hex string</td>
  <td>Account's contract code.</td>
</tr>
<tr>
  <td>Proof</td>
  <td>proof</td>
  <td>Array of hex string</td>
  <td>Merkle proof for an account. The array of hex string is an array of hashes.</td>
</tr>
</tbody>
</table>


#### StorageProofType

Storage Proof Type contains a proof for a specific storage slot in a specific account. The following table describes the information contained in the ```StorageProofType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Account</td>
  <td>account</td>
  <td>Hex string</td>
  <td>Address of an account.</td>
</tr>
<tr>
  <td>Slot</td>
  <td>slot</td>
  <td>Hex string</td>
  <td>Storage slot number.</td>
</tr>
<tr>
  <td>Value</td>
  <td>value</td>
  <td>Hex string</td>
  <td>Value at the storage slot.</td>
</tr>
<tr>
  <td>Proof</td>
  <td>proof</td>
  <td>Array of hex string</td>
  <td>Merkle proof for a storage slot. The array of hex string is an array of hashes.</td>
</tr>
</tbody>
</table>


#### ReceiptType

One ```ReceiptsType``` structure is returned for each transaction. The information in this structure is not needed to prove the execution trace of all the transactions in a block as the block header contains the final state root. However, it will assist the proving of a transaction, providing per-transaction information that can be checked. The following table describes the information contained in the ```ReceiptType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Type</td>
  <td>type</td>
  <td>Hex string</td>
  <td>Transaction type.</td>
</tr>
<tr>
  <td>Post State</td>
  <td>postState</td>
  <td>Hex string</td>
  <td>Storage root after to executing the transaction.</td>
</tr>
<tr>
  <td>Status</td>
  <td>status</td>
  <td>Boolean</td>
  <td>True if the transaction did not revert.</td>
</tr>
<tr>
  <td>Cumulative Gas Used</td>
  <td>gasUsed</td>
  <td>Number</td>
  <td>Amount of gas used by this transaction and all previous transactions in the block.</td>
</tr>
<tr>
  <td>Blooms</td>
  <td>blooms</td>
  <td>Hex string</td>
  <td>Bloom filter for log.</td>
</tr>
<tr>
  <td>Logs</td>
  <td>logs</td>
  <td>Array of <a href="#LogType">LogType</a></td>
  <td>Array of events emmitted during the transaction execution.</td>
</tr>
<tr>
  <td>Transaction Hash</td>
  <td>txHash</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Contract Address</td>
  <td>contractAddress</td>
  <td>Hex string</td>
  <td>Address of deployed contract if the transaction was a create contract, empty otherwise.</td>
</tr>
<tr>
  <td>Gas Used</td>
  <td>gasUsed</td>
  <td>Number</td>
  <td>Amount of gas used by this transaction.</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>blockNumber</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Block Hash</td>
  <td>blockHash</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Transaction Index</td>
  <td>txIndex</td>
  <td>Number</td>
  <td>Index of this transaction within the block.</td>
</tr>
<tr>
  <td>Return Value</td>
  <td>returnValue</td>
  <td>Hex string</td>
  <td></td>
</tr>
</tbody>
</table>


#### LogType

```LogType``` contains information emitted for one event during the execution of a transaction. The following table describes the information contained in the ```LogType```.

<table>
<thead>
<tr>
  <th>Field</th>
  <th>JSON Name</th>
  <th>JSON Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>Address</td>
  <td>address</td>
  <td>Hex string</td>
  <td>Address of contract that emitted the event.</td>
</tr>
<tr>
  <td>Topics</td>
  <td>topics</td>
  <td>Array or Hex string</td>
  <td>Array of log topics.</td>
</tr>
<tr>
  <td>Data</td>
  <td>data</td>
  <td>Hex string</td>
  <td>Event parameters that are not topics.</td>
</tr>
<tr>
  <td>Block Number</td>
  <td>blockNumber</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Block Hash</td>
  <td>blockHash</td>
  <td>Hex string</td>
  <td></td>
</tr>
<tr>
  <td>Transaction Index</td>
  <td>txIndex</td>
  <td>Number</td>
  <td>Index of this transaction within the block.</td>
</tr>
<tr>
  <td>Index</td>
  <td>index</td>
  <td>Number</td>
  <td>Index of this log within the transaction.</td>
</tr>
<tr>
  <td>Removed</td>
  <td>removed</td>
  <td>Boolean</td>
  <td>The ```Removed``` field is true if this log was reverted due to a chain reorganisation.</td>
</tr>
</tbody>
</table>




## Rationale

This section explains the rationale behind design decisions contained in this specification.


### Block Information data structure

The following sections explain why each piece of information is required in the Block Information data structure.

#### Chain Id

The ```Chain Id``` is required to ensure the block information is not mistakenly replayed for a different rollup.

#### Block Header

The ```Block Header``` includes information required to prove consensus.






TODO: Explain the rationale for each piece of data being returned.

## Backwards Compatibility

No backward compatibility issues found.

## Test Cases

None.

## Reference Implementation

None.


## Security Considerations

The following security implications should be considered:

* Provers should only request blocks from decentralised sequencer blockchain nodes that are final. That is, proofs should only be generated and posted to Ethereum that represent finalised blocks from the decentralised sequencer.
* Provers implicitly trust the decentralised sequencer blockchain. Decentralised sequencer blockchain nodes could collude to generate a fork of the canonical blockchain. They could deliver state to the provers based on the fork. This specification assumes that decentralised sequencer blockchain nodes will not collude.
* The consensus protocol used by the decentralised sequencer blockchain nodes should be Byzantine Fault Tolerant. That is, it should be able to handle some faulty or malicious nodes. In this way, the prover will receive the correct state, not matter which node it communicates with, even if some of the nodes in the decentralised sequencer blockchain are malicious.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
